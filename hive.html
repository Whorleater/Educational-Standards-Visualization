<!DOCTYPE html>
<meta charset="utf-8">
<style>

.link {
  fill: none;
  stroke-width: 1.5px;
}

.axis, .node {
  stroke: #000;
  stroke-width: 1.5px;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="d3.hive.min.js"></script>
<script>

var width = window.innerWidth,
    height = window.innerHeight,
    innerRadius = 40,
    outerRadius = 240;

var typeAngle = {};
typeAngle["s1"] = 0;
typeAngle["t1"] = 1;
typeAngle["t2"] = 2;

var distFromCenter = {};
var t1Amount = t2Amount = s1Amount = 0;
var angle = d3.scale.ordinal().domain(d3.range(4)).rangePoints([0, 2 * Math.PI]),
    radius = d3.scale.linear().range([innerRadius, outerRadius]),
    color = d3.scale.category10().domain(d3.range(20));

// var nodes = [
//   {x: 0, y: .1},
//   {x: 0, y: .9},
//   {x: 1, y: .2},
//   {x: 1, y: .3},
//   {x: 2, y: .1},
//   {x: 2, y: .8}
// ];
//
// var links = [
//   {source: nodes[0], target: nodes[2]},
//   {source: nodes[1], target: nodes[3]},
//   {source: nodes[2], target: nodes[4]},
//   {source: nodes[2], target: nodes[5]},
//   {source: nodes[3], target: nodes[5]},
//   {source: nodes[4], target: nodes[0]},
//   {source: nodes[5], target: nodes[1]},
//     {source: nodes[5], target: nodes[4]},
//     {source: nodes[5], target: nodes[3]}
// ];


d3.json("revised-data/t1-s1.json", function(nodes) {
  var nodesByName = {},
      links = [],
      formatNumber = d3.format(",d"),
      defaultInfo;

  // Construct an index by node name.
  nodes.forEach(function(d) {
    d.connectors = [];
    d.packageName = d.name.split(".")[1];
    nodesByName[d.name] = d;
  });

  // Convert the import lists into links with sources and targets.
  nodes.forEach(function(source) {
    source.imports.forEach(function(targetName) {
      var target = nodesByName[targetName];
      if (!source.source) source.connectors.push(source.source = {node: source, degree: 0});
      if (!target.target) target.connectors.push(target.target = {node: target, degree: 0});
      links.push({source: source.source, target: target.target});
    });
  });
  
  nodes.forEach(function(node) {
      if (node.type == "t1") {
          node.y = t1Amount;
          t1Amount += .01;
      }
      else if (node.type == "t2"){
          node.y = t2Amount;
          t2Amount += .01;
      }
      else {
          node.y = s1Amount;
          s1Amount += .01;
      }
  });
  console.log(nodesByName);
  console.log(links);
  
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

svg.selectAll(".axis")
    .data(d3.range(3))
  .enter().append("line")
    .attr("class", "axis")
    .attr("transform", function(d) { return "rotate(" + degrees(angle(d)) + ")"; })
    .attr("x1", radius.range()[0])
    .attr("x2", radius.range()[1]);

// svg.selectAll(".links")
//     .data(links)
//   .enter().append("path")
//     .attr("class", "link")
//     .attr("d", d3.hive.link()
//     .angle(function(d) { return angle(typeAngle[d.type]); })
//     .radius(function(d) { return radius(d.y); }))
//     //.style("stroke", function(d) { return color(d.source.x); })
//     ;

svg.selectAll(".node")
    .data(nodes)
  .enter().append("circle")
    .attr("class", "node")
    .attr("transform", function(d) { return "rotate(" + degrees(angle(typeAngle[d.type])) + ")"; })
    .attr("cx", function(d) { return radius(d.y); })
    .attr("r", 4)
    .style("fill", function(d) { return color(typeAngle[d.type]); })
    ;
  
});


function degrees(radians) {
  return radians / Math.PI * 180 - 90;
}

</script>